<!DOCTYPE html>
<!-- 
3DGP14 MODULE 4
ASSIGNMENT 1
By: Juhani Koivulainen
// TODO: Add FPS controls, maybe add a mesh
-->
<html>
    <head>
        <title>Scene hierarchy</title>
        <style>
            body {
                background: #777;
                color: #FFF;
                font-family: arial, serif, sans-serif;
                font-size: 16px;
                -ms-user-select: none;
                -moz-user-select: none;
                -webkit-user-select: none;
            }
            #container {
                top: 0px; left: 0px;
                border: 3px solid #FFF;
            }
        </style>
    </head>
    <body>
        <!--<canvas id="can" width="800" height="600">Your browser does not support HTML5 canvas element</canvas>-->
        <div id="container"></div><br>
        Use WASD to rotate camera
    <script src="lib/three.min.js"></script>
    <script>
    // General vars
    var $ = function(id) {return document.getElementById(id);},
        // DOM stuff
        container = $("container"),
        // App stuff
        timer = new Timer(),
        handAngle = 0,
        up = down = left = right = false,
        cameraDistance = 400,
        cameraAngle = 0,
        // webGL stuff
        renderer = new THREE.WebGLRenderer(),
        width = window.innerWidth * .98,
        height = window.innerHeight * .85,
        camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000),
        camObject = new THREE.Object3D(),
        scene = new THREE.Scene();
        
    // Initialization
    window.onload = function() {
        var randomMaterial = function() { return new THREE.MeshBasicMaterial({color: Math.random() * 0xFFFFFF }); },
            sphereGeometry = new THREE.SphereGeometry(10, 32, 32),  // for the joints
            rockTexture = THREE.ImageUtils.loadTexture("rock.jpg");
            
        // Set texture to repeat
        rockTexture.wrapS = THREE.RepeatWrapping;
        rockTexture.wrapT = THREE.RepeatWrapping;
        
        // Setup renderer DOM
        renderer.setClearColor(0x11212A, 1);
        renderer.setSize(width, height);
        container.style.width = width +"px";
        container.style.height = height +"px";
        container.appendChild(renderer.domElement);
        
        // Ground
        var ground = new THREE.Mesh(new THREE.CubeGeometry(600, 600, 0.1, 1, 1, 1), new THREE.MeshBasicMaterial({ map: rockTexture }));
        ground.name = "ground";
        scene.add(ground);
        
        // Create the hand
        var thumb    = new THREE.Mesh(new THREE.CubeGeometry(20, 3, 3), randomMaterial()),
            finger1  = new THREE.Mesh(new THREE.CubeGeometry(5, 5, 20), randomMaterial()),
            finger2  = new THREE.Mesh(new THREE.CubeGeometry(5, 5, 20), randomMaterial()),
            finger3  = new THREE.Mesh(new THREE.CubeGeometry(5, 5, 20), randomMaterial()),
            palm     = new THREE.Mesh(new THREE.CubeGeometry(25, 5, 20), randomMaterial()),
            lower    = new THREE.Mesh(new THREE.CubeGeometry(10, 10, 50), randomMaterial()),
            elbow    = new THREE.Mesh(sphereGeometry, randomMaterial()),
            upper    = new THREE.Mesh(new THREE.CubeGeometry(10, 10, 50), randomMaterial()),
            shoulder = new THREE.Mesh(sphereGeometry, randomMaterial());
        
        // Adjust positions for each part
        shoulder.position.z = 10;
        upper.position.z = 30;
        elbow.position.z = 25;
        lower.position.z = 30;
        palm.position.z = 35;
        palm.name = "palm";
        finger1.position.x = -10;
        finger1.position.z = 20;
        finger2.position.x = 0;
        finger2.position.z = 20;
        finger3.position.x = 10;
        finger3.position.z = 20;
        thumb.position.x = -20;
        
        // "attach" parts by nesting them, starting from the last part
        palm.add(thumb);
        palm.add(finger1);
        palm.add(finger2);
        palm.add(finger3);
        lower.add(palm);
        elbow.add(lower);
        upper.add(elbow);
        shoulder.add(upper);
        scene.add(shoulder);
        
        // Light
        var pointLight = new THREE.PointLight(0xFFFFFF);
        scene.add(pointLight);
        
        // camera
        camObject.add(camera);
        camObject.position.y = -200;
        camObject.position.z = 70;
        camObject.position.x = 200;
        camObject.rotation.x = Math.PI / 2;
        camObject.rotation.y = Math.PI / 4;
        scene.add(camObject);
        
        // Start!
        loop();
    }
    
    function loop() {
        var dt = timer.tick();
        handAngle = (handAngle + dt) % (20 * Math.PI);
        var handRotation = Math.sin(handAngle) * (Math.PI / 20);
        var wristRotation = Math.sin(handAngle * 2) * (Math.PI / 8);
        
        if (up) cameraDistance -= 100 * dt
        if (down) cameraDistance += 100 * dt;
        if (left) cameraAngle -= dt;
        if (right) cameraAngle += dt;
        
        camObject.position.x = Math.cos(cameraAngle) * cameraDistance;
        camObject.position.y = Math.sin(cameraAngle) * cameraDistance;
        camObject.rotation.y = cameraAngle + (Math.PI / 2);
        
        // Traverse trough every nested child inside any THREE.Mesh that's name is not "ground"
        scene.traverse(function (obj) {
            if (obj instanceof THREE.Mesh && obj.name !== "ground") {
                obj.rotation.y = handRotation;
                obj.position.x += Math.cos(handAngle) * .05;
                if (obj.name === "palm") {
                    obj.rotation.x = wristRotation;
                }
            }
        });
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
    }
    
    // Game timer to determine deltatime. Copied from:
    // http://blog.sethladd.com/2011/05/source-code-slides-and-video-for-html5.html
    function Timer () {
        this.gameTime = 0;
        this.maxStep = 0.05;
        this.wallLastTime = 0;
    }
    Timer.prototype.tick = function () {
        var wallCurrent = window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
        var wallDelta = (wallCurrent - this.wallLastTime) / 1000;
        this.wallLastTime = wallCurrent;
        var gameDelta = Math.min(wallDelta, this.maxStep);
        this.gameTime += gameDelta;
        return gameDelta;
    };
    window.onkeydown = function(e) {
        switch (e.keyCode) {
            case 87:    up = true;      break;    
            case 83:    down = true;    break;
            case 65:    left = true;    break;
            case 68:    right = true;   break;
        }
    };
    window.onkeyup = function(e) {
        switch (e.keyCode) {
            case 87:    up = false;      break;    
            case 83:    down = false;    break;
            case 65:    left = false;    break;
            case 68:    right = false;   break;
        }
    };
    </script>
    </body>
</html>